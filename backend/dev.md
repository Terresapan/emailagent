# LangGraph Parallel Execution Debugging Log

## Goal
Split email digest output into two emails (Newsletter Digest + LinkedIn Content Pack) with parallel content generation for performance.

---

## What Does NOT Work in LangGraph

### ❌ Multiple Edges from Single Node
```python
# This does NOT create parallel branches
workflow.add_edge("source_node", "target_A")
workflow.add_edge("source_node", "target_B")  # Only one edge is followed!
```
LangGraph's standard `StateGraph` follows only one outgoing edge per node.

### ❌ Conditional Edges Returning List of Node Names
```python
def route(state):
    return ["node_A", "node_B"]  # Returns list of strings

workflow.add_conditional_edges("source", route, ["node_A", "node_B"])
```
This only routes to ONE node, not both.

### ❌ Conditional Edges with Send to Different Nodes (Same Data)
```python
def route(state):
    return [Send("node_A", state), Send("node_B", state)]  # Same state

workflow.add_conditional_edges("source", route, ["node_A", "node_B"])
```
This worked when used with **subgraphs as nodes**, but not with regular nodes directly.

---

## What WORKS in LangGraph

### ✅ Send Pattern for Map-Reduce (Same Node, Different Data)
```python
def fan_out(state):
    return [Send("worker_node", {"item": x}) for x in state["items"]]

workflow.add_conditional_edges("source", fan_out, ["worker_node"])
```
Each Send spawns a parallel worker with different input data.

### ✅ Subgraphs as Nodes with Send Pattern
```python
# Build compiled subgraphs
digest_subgraph = StateGraph(ProcessorState)
digest_subgraph.add_node("generate", gen_fn)
digest_subgraph.add_node("quality", qc_fn)
digest_subgraph.set_entry_point("generate")
digest_subgraph.add_edge("generate", "quality")
digest_subgraph.add_edge("quality", END)
compiled_digest = digest_subgraph.compile()

# Add as nodes to main graph
workflow.add_node("digest_branch", compiled_digest)
workflow.add_node("linkedin_branch", compiled_linkedin)

# Fan out using Send
def fan_out(state):
    return [Send("digest_branch", state), Send("linkedin_branch", state)]

workflow.add_conditional_edges("prepare", fan_out, ["digest_branch", "linkedin_branch"])
```
This spawns two parallel subgraph executions!

### ✅ Custom Reducers for Parallel State Merge
When parallel branches complete, LangGraph merges their states. All fields must have reducers:

```python
def last_non_empty(left: str, right: str) -> str:
    return right if right else left

def last_list(left: List, right: List) -> List:
    return right if right else left

class ProcessorState(TypedDict):
    emails: Annotated[List[Email], last_list]
    digests: Annotated[List[EmailDigest], add]  # Built-in add reducer
    briefing: Annotated[str, last_non_empty]
    errors: Annotated[List[str], add]
```

---

## Race Condition Gotcha

### ❌ The Bug
Parallel subgraphs can't share data generated by each other:
```
prepare_content → digest_branch (generates newsletter_summaries)
               → linkedin_branch (needs newsletter_summaries - empty!)
```

### ✅ The Fix
Generate shared data BEFORE fan-out:
```python
def prepare_content_generation(state):
    # Generate newsletter_summaries HERE, not in subgraph
    summaries = format_summaries(state["digests"])
    return {"newsletter_summaries": summaries}  # Now both branches have it
```

---

## Final Working Architecture

```
distribute_emails
       ↓
[email workers] ← Parallel via Send (map-reduce)
       ↓
prepare_content_generation ← Synchronization + generates shared data
       ↓
┌──────┴──────┐
↓             ↓
digest_branch linkedin_branch ← Parallel via Send to subgraphs
↓             ↓
END          END ← LangGraph merges states using reducers
```

---

## Key Lessons Learned

1. **Send pattern is for workers, not routing** - Use subgraphs if you need different logic in parallel branches
2. **Synchronization nodes matter** - Create a node before fan-out to prepare shared data
3. **Every field needs a reducer** - Otherwise parallel merge fails with `InvalidUpdateError`
4. **Built-in `add` reducer only works for lists** - Create custom reducers for strings and other types
5. **Check logs for missing steps** - If a node doesn't log, it's not being called
6. **Race conditions are silent** - Early returns (if empty, return) can hide parallel timing issues
